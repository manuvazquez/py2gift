# AUTOGENERATED! DO NOT EDIT! File to edit: 80_markdown.ipynb (unless otherwise specified).

__all__ = ['markdown_header', 'html_question_to_markdown', 'numerical_to_markdown', 'multiple_choice_to_markdown',
           'SvgToMarkdown', 'from_question', 'pre_processors', 'settings_to_markdown']

# Cell
import string
import functools
from typing import Union, List

# to avoid tqdm's experimental warning
import warnings
warnings.filterwarnings("ignore", message='Using `tqdm.autonotebook.tqdm` in notebook mode')

import gift_wrapper.question
import gift_wrapper.latex
import gift_wrapper.parsing
import gift_wrapper.process

import py2gift.util

# Cell
def markdown_header(
        text: str,
        template: string.Template = string.Template('<span style="font-family:Papyrus; font-size:2em;">$text</span>')
    ) -> str:
    """
    Returns a markdown header for a given text.

    **Parameters**

    - `text` : str

        Text for the header.

    - `template` : string template

        The template that defines the appearance of the header, and in which `text` will be embedded.

    **Returns**

    - `out` : str
        Markdown-compatible text.

    """

    return f'\n{template.substitute(text=text)}\n\n'

# Cell
def html_question_to_markdown(self):

    statement = self.statement

    # if a `time` estimate was passed...
    if self.time:

        # ...it is appended at the end of the statement
        statement += f'\n\n\n*Estimated time: {self.time} minutes*\n'

    feedback = (f'{markdown_header("Feedback")}' + self.feedback.rstrip()) if self.feedback else ''

    # a copy of each list is made so that the class attribute is not modified
    latex_in_text_substitutions = [e.copy() for e in gift_wrapper.parsing.latex_in_text_substitutions[:2]]

    # \textbf-related substitutions are tweaked
    latex_in_text_substitutions[0][1] = r'**\1**'
    latex_in_text_substitutions[0][2] = r'\*\*([^\*]+)\*\*'

    # \textit-related substitutions are tweaked
    latex_in_text_substitutions[1][1] = r'*\1*'
    latex_in_text_substitutions[1][2] = r'\*([^\*]+)\*'

    # just like LaTeX, in markdown a single "newline" doesn't reflect in the output, and hence every new line
    # is duplicated
    latex_in_text_substitutions += [['\n', '\n\n', '\n\n', '\n']]

    def apply_substitutions(text: str, substitutions: list):

        res = text

        for s in substitutions:

            res = gift_wrapper.latex.replace_and_replace_only_in_formulas(*s, res)

        return res

    statement = apply_substitutions(statement, latex_in_text_substitutions)
    feedback = apply_substitutions(feedback, latex_in_text_substitutions)

    return f'{markdown_header("Statement")}{statement}\n{feedback}\n'

gift_wrapper.question.HtmlQuestion.to_markdown = html_question_to_markdown

# Cell
def numerical_to_markdown(self):

    res = super(gift_wrapper.question.Numerical, self).to_markdown()

    return res + f'{markdown_header("Solution")} {self.solution_value} (error: {self.solution_error[1:]})\n'

gift_wrapper.question.Numerical.to_markdown = numerical_to_markdown

# Cell
def multiple_choice_to_markdown(self):

    res = super(gift_wrapper.question.MultipleChoice, self).to_markdown()

    res += markdown_header('Choices')

    if 'perfect' in self.answers:

        # res += f'---\n'

        # res += f'* {self.answers["perfect"]}\n'
        res += f'* {self.template_wrong_answers.substitute(color="green", text=self.answers["perfect"])}\n'

        # res += f'---\n'

    for a in self.answers['wrong']:

        if isinstance(a, list):

            formatted_grade = self.template_wrong_answers.substitute(
                color='green' if float(a[1]) > 0 else 'red', text=f'{a[1]}%')

            res += f'* {a[0]} (**{formatted_grade}**)\n'
            # res += f'* {a[0]} (**{a[1]}%**)\n'

        else:

            # res += f'* {a}\n'
            res += f'* {self.template_wrong_answers.substitute(color="red", text=a)}\n'

    return res

gift_wrapper.question.MultipleChoice.to_markdown = multiple_choice_to_markdown

# Cell
class SvgToMarkdown(gift_wrapper.process.Processor):
    """
    Processor to reformat svg files for including them in markdown strings.
    """

    def __init__(self):

        super().__init__()

        def process_match(f):

            pass

        self.function = functools.partial(
            gift_wrapper.process.process_paths, pattern=gift_wrapper.parsing.svg_file, process_match=process_match,
            replacement=r'![](' + r'\1)')

# Cell
def from_question(q: gift_wrapper.question.HtmlQuestion, processors: List[gift_wrapper.process.Processor]) -> str:
    """
    Returns the markdown representation of a question.

    **Parameters**

    - `q` : gift_wrapper.question.HtmlQuestion

        The question object.

    - `processors` : list

        Processors to be applied.

    **Returns**

    - `out` : str
        Markdown-compatible text.

    """

    markdown = q.to_markdown()

    for f in processors:

        markdown = f(markdown)

    return markdown

# Cell
pre_processors = [
    gift_wrapper.process.TexToSvg({'already compiled': set(), 'already transferred': set()}), SvgToMarkdown()]

# Cell
def settings_to_markdown(settings: dict) -> str:
    """
    Returns a markdown representation of the question given the corresponding settings.

    **Parameters**

    - `settings` : dict

        User settings (usually read from a YAML file).

    **Returns**

    - `markdown`: str

        Markdown representation

    """

    class_name = gift_wrapper.question.user_settings_to_class_init(settings, 'unnamed')
    cls = getattr(gift_wrapper.question, class_name)

    return from_question(cls(**settings), pre_processors)